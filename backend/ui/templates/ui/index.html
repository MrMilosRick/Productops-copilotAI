<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ProductOps Copilot UI</title>
  <style>
    body { font-family: ui-sans-serif, system-ui, -apple-system; margin: 24px; max-width: 980px; }
    h1 { margin: 0 0 8px; }
    .muted { color: #666; margin-bottom: 16px; }
    .row { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; }
    textarea, input, select { width: 100%; padding: 10px; font-size: 14px; }
    textarea { min-height: 140px; }
    button { padding: 10px 14px; font-size: 14px; cursor: pointer; }
    pre { background: #f6f6f6; padding: 12px; overflow: auto; border-radius: 10px; }
    .card { border: 1px solid #eee; border-radius: 10px; padding: 14px; margin: 14px 0; }
    .ok { color: #0a7; }
    .err { color: #c00; }
    table { width: 100%; border-collapse: collapse; }
    td, th { border-bottom: 1px solid #eee; padding: 8px; text-align: left; vertical-align: top; }
    .inline { display:flex; gap:10px; align-items:center; flex-wrap: wrap; }
    .badge { font-size: 12px; padding: 2px 8px; border-radius: 999px; background:#f3f3f3; }
  </style>
</head>
<body>
  <h1>ProductOps Copilot UI</h1>
  <div class="muted">Thin demo UI over the RAG engine API: upload → ask → sources → trace.</div>

  <div class="card">
    <h3>0) Documents</h3>
    <div class="inline">
      <button id="btnDocs">Refresh docs</button>
      <span id="docsStatus" class="muted"></span>
      <span class="badge">GET /api/kb/documents/</span>
    </div>
    <div class="row" style="margin-top:10px;">
      <div>
        <label>Select document</label>
        <select id="docSelect">
          <option value="">—</option>
        </select>
      </div>
      <div>
        <label>Selected document_id</label>
        <input id="docIdInput" placeholder="document_id" />
      </div>
    </div>
  </div>

  <div class="card">
    <h3>1) Upload text document</h3>
    <div class="row">
iv>
        <label>Title</label>
        <input id="title" placeholder="Demo doc title" />
      </div>
      <div>
        <label>Top-k</label>
        <input id="topk" type="number" value="3" min="1" max="20" />
      </div>
    </div>
    <label>Content</label>
    <textarea id="content" placeholder="Paste text here..."></textarea>
    <div class="inline" style="margin-top:10px;">
      <button id="btnUpload">Upload</button>
      <span id="uploadStatus" class="muted"></span>
      <span class="badge">POST /api/kb/upload_text/</span>
    </div>
    <div style="margin-top:10px;">
      <div><b>status:</b> <span id="docStatus" class="muted">—</span></div>
    </div>
  </div>

  <div class="card">
    <h3>2) Ask (scoped to document_id)</h3>
    <label>Question</label>
    <input id="question" placeholder="Ask something..." />
    <div class="inline" style="margin-top:10px;">
      <button id="btnAsk">Ask</button>
      <span id="askStatus" class="muted"></span>
      <span class="badge">POST /api/ask/</sp>
    </div>
  </div>

  <div class="card">
    <h3>Answer</h3>
    <div><b>retriever_used:</b> <span id="retrieverUsed" class="muted">—</span></div>
    <div><b>run_id:</b> <span id="runId" class="muted">—</span></div>
    <pre id="answer" style="white-space:pre-wrap;">—</pre>

    <h3>Sources</h3>
    <table id="sourcesTbl">
      <thead>
        <tr>
          <th>doc</th>
          <th>chunk</th>
          <th>score</th>
          <th>snippet</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
  </div>

  <div class="card">
    <h3>Trace</h3>
    <div class="inline">
      <button id="btnTrace">Show trace (steps)</button>
      <span id="traceStatus" class="muted"></span>
      <span class="badge">GET /api/runs/&lt;run_id&gt;/steps/</span>
    </div>
    <pre id="trace" style="white-space:pre-wrap;">—</pre>
  </div>

<script>
const API = "/api";
const el = (id) => document.getElementById(id);

async function apiFetch(path, opts={}) {
  const res = await fetch(API + path, {
    h{ "Content-Type": "application/json", ...(opts.headers||{}) },
    ...opts,
  });
  const txt = await res.text();
  let data;
  try { data = JSON.parse(txt); } catch { data = { raw: txt }; }
  if (!res.ok) throw new Error((data && data.detail) ? JSON.stringify(data.detail) : txt);
  return data;
}

function renderSources(sources) {
  const tbody = el("sourcesTbl").querySelector("tbody");
  tbody.innerHTML = "";
  (sources || []).forEach(s => {
    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td>${s.document_id ?? ""}</td>
      <td>${s.chunk_index ?? s.chunk_id ?? ""}</td>
      <td>${(s.score ?? "").toString().slice(0,8)}</td>
      <td>${(s.snippet ?? "").toString()}</td>
    `;
    tbody.appendChild(tr);
  });
}

async function pollDoc(docId) {
  for (let i=0;i<60;i++) {
    const d = await apiFetch("/kb/documents/" + docId + "/", { method: "GET", headers: {} });
    el("docStatus").textContent = d.status || "—";
    if ((d.status || "").toLowerCase() === "embedded") return d;
  await new Promise(r => setTimeout(r, 1000));
  }
  throw new Error("timeout waiting for embedded");
}

async function refreshDocs() {
  el("docsStatus").textContent = "loading...";
  el("docsStatus").className = "muted";
  try {
    const docs = await apiFetch("/kb/documents/", { method: "GET", headers: {} });
    const sel = el("docSelect");
    sel.innerHTML = '<option value="">—</option>';
    (docs || []).slice(0, 50).forEach(d => {
      const opt = document.createElement("option");
      opt.value = d.id;
      opt.textContent = `#${d.id} — ${d.title} [${d.status}]`;
      sel.appendChild(opt);
    });
    el("docsStatus").textContent = "ok ✓";
    el("docsStatus").className = "ok";
  } catch (e) {
    el("docsStatus").textContent = "error: " + e.message;
    el("docsStatus").className = "err";
  }
}

el("btnDocs").addEventListener("click", refreshDocs);
el("docSelect").addEventListener("change", () => {
  const v = el("docSelect").value;
  el("docIdInput").value = v || "";
});

el("btnUpload")entListener("click", async () => {
  el("uploadStatus").textContent = "uploading...";
  el("uploadStatus").className = "muted";
  try {
    const title = el("title").value || ("UI Doc " + Date.now());
    const content = el("content").value || "Hello from UI.";
    const r = await apiFetch("/kb/upload_text/", {
      method: "POST",
      body: JSON.stringify({ title, content }),
    });

    const docId = r.document_id;
    el("docIdInput").value = docId;
    el("docStatus").textContent = r.status || "uploaded";

    el("uploadStatus").textContent = "queued ✓ (waiting for embedded...)";
    el("uploadStatus").className = "ok";

    await pollDoc(docId);
    el("uploadStatus").textContent = "embedded ✓";
    el("uploadStatus").className = "ok";

    await refreshDocs();
    el("docSelect").value = String(docId);
  } catch (e) {
    el("uploadStatus").textContent = "error: " + e.message;
    el("uploadStatus").className = "err";
  }
});

el("btnAsk").addEventListener("click", async () => {
  el("askStatutextContent = "asking...";
  el("askStatus").className = "muted";
  try {
    const docId = parseInt(el("docIdInput").value || "", 10);
    if (!docId) throw new Error("select/upload a document first (document_id is empty)");
    const question = el("question").value || "What is this document about?";
    const top_k = parseInt(el("topk").value || "3", 10);

    const r = await apiFetch("/ask/", {
      method: "POST",
      body: JSON.stringify({ question, retriever: "auto", top_k, document_id: docId }),
    });

    el("retrieverUsed").textContent = r.retriever_used || "—";
    el("runId").textContent = r.run_id || "—";
    el("answer").textContent = r.answer || JSON.stringify(r, null, 2);
    renderSources(r.sources || []);

    el("trace").textContent = "—";
    el("traceStatus").textContent = "";

    el("askStatus").textContent = "ok ✓";
    el("askStatus").className = "ok";
  } catch (e) {
    el("askStatus").textContent = "error: " + e.message;
    el("askStatus").className = "err";
  }
});
Trace").addEventListener("click", async () => {
  el("traceStatus").textContent = "loading...";
  el("traceStatus").className = "muted";
  try {
    const runId = (el("runId").textContent || "").trim();
    if (!runId || runId === "—") throw new Error("ask first (run_id is empty)");
    const steps = await apiFetch("/runs/" + runId + "/steps/", { method: "GET", headers: {} });
    el("trace").textContent = JSON.stringify(steps, null, 2);
    el("traceStatus").textContent = "ok ✓";
    el("traceStatus").className = "ok";
  } catch (e) {
    el("traceStatus").textContent = "error: " + e.message;
    el("traceStatus").className = "err";
  }
});

// auto-load docs on open
refreshDocs();
</script>
</body>
</html>
